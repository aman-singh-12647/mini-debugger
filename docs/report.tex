\documentclass[11pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}

% Geometry settings for a dense technical report
\geometry{
    left=20mm,
    right=20mm,
    top=15mm,
    bottom=15mm,
}

% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{
    \textbf{Lab 2: Mini-Debugger: Technical Report}
}
\author{2025MCS2121 Gaurav Jain\\ 2025MCS2122 Aman Singh}
\date{17 December 2025}

\begin{document}

\maketitle

\section{Introduction}

\subsection{Problem Statement and Scope}
This project entails the development of a minimal debugger for ELF binaries on the Linux operating system. The primary objective is to load, control, inspect, and step through processes using OS-level debugging primitives, specifically avoiding high-level tools like GDB. The debugger is required to support breakpoint management, single-stepping, register inspection, and status reporting.

\subsection{Design Philosophy}
The system is designed as a lightweight command-line interface (CLI) tool. It operates by forking a child process to execute the target binary while the parent process acts as the tracer. This architecture leverages the Linux \texttt{ptrace} API for process control and memory manipulation, ensuring strict adherence to the non-functional requirement of not corrupting the debugger's state.

\section{System Architecture}

The debugger is modularized into five core components, managed by a central event loop in \texttt{main.c}.

\subsection{Process Control (\texttt{debugger.c})}
The debugger initiates the session using a standard \texttt{fork()} and \texttt{exec()} pattern.
\begin{itemize}
    \item \textbf{Child Process}: Executes \texttt{ptrace(PTRACE\_TRACEME, ...)} to allow the parent to trace it, then calls \texttt{execl()} to replace its memory image with the target program.
    \item \textbf{Parent Process}: Uses \texttt{waitpid()} to synchronize with the child. It issues \texttt{ptrace} commands to control execution (e.g., \texttt{PTRACE\_CONT}) and intercepts signals (like \texttt{SIGTRAP}) generated by breakpoints.
\end{itemize}

\subsection{Breakpoint Management (\texttt{breakpoints.c})}
This module manages a data structure of active breakpoints. The key challenge is safely modifying the instruction stream of the running process without permanently corrupting the binary.
\begin{itemize}
    \item \textbf{Insertion}: The debugger reads the instruction word at the target address using \texttt{PTRACE\_PEEKTEXT}. It preserves the least significant byte (LSB) in the \texttt{breakpoint} struct and replaces it with the \texttt{INT 3} opcode (\texttt{0xCC}).
    \item \textbf{Restoration}: To remove a breakpoint or resume execution, the original byte is restored using bitwise operations: \texttt{(data \& \textasciitilde0xFF) | original\_byte}.
\end{itemize}

\section{Technical Implementation}

\subsection{The Breakpoint Mechanism}
The core complexity lies in handling the \texttt{SIGTRAP} signal when a breakpoint is hit.
\begin{enumerate}
    \item When the CPU executes \texttt{0xCC}, it halts the child process and sends \texttt{SIGTRAP} to the parent.
    \item The parent inspects the Instruction Pointer (\texttt{RIP}) via \texttt{PTRACE\_GETREGS}.
    \item Since the CPU advances \texttt{RIP} after fetching the instruction, the \texttt{RIP} will be one byte past the breakpoint address.
    \item The debugger detects this condition: \texttt{if (regs.rip - 1 == bp->addr)}.
    \item To resume, the debugger must:
    \begin{itemize}
        \item Restore the original instruction byte.
        \item Decrement \texttt{RIP} by 1 (\texttt{regs.rip -= 1}) so the original instruction is executed.
        \item Update the child's registers via \texttt{PTRACE\_SETREGS}.
    \end{itemize}
\end{enumerate}

\begin{lstlisting}[language=C, caption={Handling Breakpoint Hit}]
void handle_breakpoint(pid_t pid, struct breakpoint *bp)
{
  struct user_regs_struct regs;
  ptrace(PTRACE_GETREGS, pid, NULL, &regs);

  if (regs.rip - 1 == (unsigned long)bp->addr)
  {
    // Restore original code and reset instruction pointer
    remove_breakpoint(pid, bp);
    regs.rip -= 1;
    ptrace(PTRACE_SETREGS, pid, NULL, &regs);
    printf("Hit breakpoint at %p\n", bp->addr);
  }
}
\end{lstlisting}

\subsection{Single Stepping}
Single-stepping is implemented via \texttt{ptrace(PTRACE\_SINGLESTEP, ...)}. This places the processor in a mode where it executes one machine instruction and then raises a \texttt{SIGTRAP}, returning control to the debugger. This is essential for fine-grained analysis of control flow.

\subsection{Register Inspection}
Register states are retrieved using \texttt{ptrace(PTRACE\_GETREGS, ...)}, which populates the \texttt{sys/user.h} defined \texttt{user\_regs\_struct}. The debugger outputs critical 64-bit registers (RIP, RSP, RAX, RBX, etc.) to standard output, allowing users to verify variable values and stack pointers during execution.

\section{Testing and Validation}
The project includes a custom unit testing framework defined in \texttt{tests/test\_framework.h}. The framework macros (\texttt{TEST}, \texttt{ASSERT\_EQ}) facilitate automated validation of:
\begin{itemize}
    \item \textbf{Data Structures}: Verifying breakpoint struct initialization and flag management.
    \item \textbf{Integration}: An automated test creates a dummy C program, compiles it, and verifies that the debugger can attach and control it without crashing.
    \item \textbf{Status Macros}: Validates correct interpretation of \texttt{WIFEXITED} and \texttt{WIFSTOPPED} macros across different OS environments.
\end{itemize}

\section{Conclusion}
The Mini-Debugger successfully meets all functional requirements set forth in Lab 2A. By directly manipulating process memory and execution flow via \texttt{ptrace}, the tool provides a robust environment for binary analysis. The implementation demonstrates a solid understanding of low-level system programming concepts, including signal handling, opcode injection, and register manipulation.


\section*{Appendix}

\subsection*{A1. Demo Screenshot}
\begin{figure}[H]
    \centering
\includegraphics[width=0.8\textwidth]{images/demo.png}
    \caption{Debugger Interactive Session}
    \label{fig:demo}
\end{figure}

\subsection*{A2. Commit History}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{images/commit1.png}
        \includegraphics[width=0.45\textwidth]{images/commit2.png}
            \\
            \includegraphics[width=0.45\textwidth]{images/commit3.png}
    \caption{Project Commit History}
    \label{fig:gitlog}
\end{figure}

\end{document}